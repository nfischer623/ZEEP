/* autogenerated by Processing revision 1296 on 2025-03-05 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class combined_fractals extends PApplet {

//graph size
float minX = -2;
float maxX = 2;
float minY = -1.5f;
float maxY = 1.5f;

//max iterations
int maxiter = 100;

//user inputs:
//palette: #006699, #ae82fa, #f261b1, #ffb433
int[] colorPicks = {0xFF006699, 0xFFAE82FA, 0xFFF261B1, 0xFFFFB433};
//varieties: "mandelbrot", "julia", "newton"
String variety = "mandelbrot";

public void setup(){
  /* size commented out by preprocessor */;
}

public void draw(){
  loadPixels();
  
  //pixel mapping and mandelbrot math from https://thecodingtrain.com/challenges/21-mandelbrot-set-with-p5js
  //for each pixel
  for (int x = 0; x < width; x++) {
    for (int y = 0; y < height; y++) {
      
      //puts math on a smaller interval
      var a = map(x, 0, width, minX, maxX);
      var b = map(y, 0, height, minY, maxY);
      
     //number of iterations
      var n = 0;
            
      if (variety == "mandelbrot"){
        n = mandelbrot(a, b, n);
      }else
      if (variety == "julia"){
        n = julia(a, b, n);
      }else
      if (variety == "newton"){
        n = newtonCountIterations(a, b, n);
      }
      
      //pixel location within a 1d array
      int location = (x + y*width);
      
      //grayscale color scheme if no given colors
      if (colorPicks.length <= 1) {
        var grayscale=map(n, 0, 100, 0, 250);
        //sets pixel color
        pixels[location]=color(grayscale);
      }
           
      //color scheme given user's picks
      if (colorPicks.length > 1) {
        addColor(n, location);
      }

        }  
      }
      updatePixels();
    }

public void keyPressed(){
  //center point in window
  float xCenter = (minX + maxX)/2;
  float yCenter = (minY + maxY)/2;
  
  float rangex = maxX - minX;
  //zoom factor
  float zoomIn = .3f * rangex;
  float zoomOut = .9f * rangex;
  
  //zoom in
  if (key == '+' || key == '=') {
    minX = xCenter - zoomIn;
    maxX = xCenter + zoomIn;
    minY = yCenter - .8f*zoomIn;
    maxY = yCenter + .8f*zoomIn;
  }
  //zoom out
  if (key == '_' || key == '-') {
    minX = xCenter - zoomOut;
    maxX = xCenter + zoomOut;
    minY = yCenter - .8f*zoomOut;
    maxY = yCenter + .8f*zoomOut;
  }
  //save as image
  if (key == 's' || key == 'S'){
    saveImage();
  }
  //save as .zeep
  if (key == 'z' || key == 'Z'){
    saveZeep();
  }  
  //load .zeep
  if (key == 'l' || key == 'L'){
    loadZeep();
  }
  if (key == 'p' || key == 'P'){
    juliaPaused = !juliaPaused;
    if (juliaPaused==true){
      juliaX = mouseX;
      juliaY = mouseY;
    }
  }
}

public void mouseDragged(){
  //rate of change of movement based on scale of graph
  float delta = .0025f * abs(maxX - minX);
  
  //determines direction mouse is moving in
  if (pmouseX < mouseX) {
    //shifts range that window sees
    minX = minX - delta;
    maxX = maxX - delta;
  }
  if (pmouseX > mouseX) {
    minX = minX + delta;
    maxX = maxX + delta;
  }
    if (pmouseY < mouseY) {
    minY = minY - delta;
    maxY = maxY - delta;
  }
  if (pmouseY > mouseY) {
    minY = minY + delta;
    maxY = maxY + delta;
  }
  
}
public void addColor(int n, int location){
    var myColor = 0;
  
    int numColors = colorPicks.length;
    for (int i=0; i<numColors; i++){
      //divides number of iterations into groups based on number of colors
      if (n >= (i*maxiter)/numColors && n <= ((i+1)*maxiter)/numColors) {
        myColor=colorPicks[i];
      }
  }
    //sets pixel color
    pixels[location]=color(myColor);
}
//julia set variables
boolean juliaPaused = false;
float juliaX;
float juliaY;

public int julia(float a, float b, int n){
  /*Function to render Julia set fractals
  Takes in complex number a+bi, max number of iterations, n
  Returns how many iterations were completed, n
  */
  float realc;
  float imagc;
  
  if (juliaPaused==false){
    //set Julia constant based on mouse
    realc= map(mouseX, 0, width, -1, 1);
    imagc= map(mouseY, 0, height, -1, 1);
  }else{
    realc= map(juliaX, 0, width, -1, 1);
    imagc=map(juliaY, 0, height, -1, 1);
  }
  
  while (n < maxiter) {
    //(a+bi)^2 = a^2 + 2abi - b^2
    // real component
    var real= a*a - b*b;
    //imaginary component
    var imag = 2*a*b;
    
    //next iteration components
    a=real + realc;
    b=imag+ imagc;
    
    //checks if point is going towards infinity
    if (a*a + b*b > 4) {
      break;
    }
    
    //increments iteration counter
    n++;
  }
  return n;
}
public void saveImage(){
  //creates "unique" file name based on date and time
  String fileName = "myFractal" + String.valueOf(month()) + "_" + String.valueOf(day()) + "_" 
                    + String.valueOf(hour()) + String.valueOf(minute()) + ".png";
  //saves to sketch folder
  save(fileName);
  println("Image saved as " + fileName);
}

public void saveZeep(){
  //saves fractal info to a .zeep file
  String [] fracFacts = {variety, str(minX), str(maxX), str(minY), str(maxY)};
  for (int i = 0; i < colorPicks.length; i++){
    String strColor = str(colorPicks[i]);
    fracFacts = append(fracFacts, strColor);
  }
  saveStrings("fractal.zeep", fracFacts);
  println("Fractal saved as 'fractal.zeep'");
}


public void loadZeep(){
  //loads .zeep file to regenerate fractal
 String [] loadedFrac = loadStrings("fractal.zeep"); 
 //variety = loadedFrac[0];
 
 minX = PApplet.parseFloat(loadedFrac[1]);
 maxX = PApplet.parseFloat(loadedFrac[2]);
 minY = PApplet.parseFloat(loadedFrac[3]);
 maxY = PApplet.parseFloat(loadedFrac[4]);
 
 /*
 color [] loadColors = {};
 for (int i = 5; i < loadedFrac.length-5; i++){
   loadColors = append(loadColors, unhex(loadedFrac[i]));
 }
 colorPicks = loadColors;
 */
 println("'fractal.zeep' loaded");
}
public int mandelbrot (float a, float b, int n){
  /*Mandelbrot Fractal function
  Takes in complex number a+bi, max number of iterations, n
  Returns how many iterations were completed, n
  */
  
  //real component
  var start_real = a;
  //imaginary component
  var start_i = b;
  
  //makes faster by setting center of mandelblobs to max iterations
  if (((a + .25f)*(a + .25f) + .81f*b*b <= .25f) || ((a+1)*(a+1) + b*b <= .06f)){
    n = maxiter;
  }
  
  while (n < maxiter) {
    //(a+bi)^2 = a^2 + 2abi - b^2
    // real component
    var new_real = a*a - b*b;
    //imaginary component
    var new_i = 2*a*b;
    
    //next iteration components
    a = new_real + start_real;
    b = new_i + start_i;
    
    //checks if point is going towards infinity
    if (a*a + b*b > 4) {
      break;
    }
    //increments iteration counter
    n++;
  }
  return n;
}
//roots for x^3 - 1
// 1 + 0i
float root1_real = 1;
float root1_i = 0;

//-1/2 + (sqrt(3)/2)i
float root2_real = -.5f;
float root2_i = sqrt(3)/2;

//-1/2 - (sqrt(3)/2)i
float root3_real = -.5f;
float root3_i = -(sqrt(3)/2);

public float [] NewtonsMethod(float a, float b){
    //applies Newton's Method to a complex number a + bi
    //Newton's Method: x(n+1) = xn - f(xn)/f'(xn)
    //But broken down into real and imaginary parts
    float denominator = 3*(a*a*a*a + 2*a*a*b*b + b*b*b*b);
    a = a - ((a*a*a*a*a + 2*a*a*a*b*b - a*a + a*b*b*b*b +b*b)/denominator);
    b = b - ((a*a*a*a*b+ 2*a*a*b*b*b + 2*a*b + b*b*b*b*b)/denominator);
    float [] new_num = {a, b};
    return new_num;
}

public int newtonCountIterations(float a, float b, int n){
  while (n < maxiter){
      float[] newnum = NewtonsMethod(a,b);
      a = newnum[0];
      b = newnum[1];
      n++;
    if (a*a + b*b > 3) {
      break;
    }
  }
  return n;
}

public float distance(float a, float b, float rootreal, float rooti){
  //finds distance between a two points: (a, b) and (rootreal, rooti)
  float dis = sqrt((a - rootreal)*(a - rootreal) + (b - rooti)*(b - rooti));
  return dis;
}


  public void settings() { size(1400, 1050); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "combined_fractals" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
